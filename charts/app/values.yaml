global:
  aws:
    # global.aws.accountId -- The AWS account that this application is being deployed into
    # @default -- Taken from deployment pipeline environment
    # @section -- global
    accountId: ""
  ingress:
    # global.ingress.enabled -- Set to `true` to expose the application with a Kubernetes `Ingress`
    # @section -- global
    enabled: false

    # global.ingress.host -- Ingress host used to configure cloudfront target
    # @section -- global
    host: ""

    # global.ingress.annotations -- Set annotations on the `Ingress`
    # @section -- global
    annotations: {}

    # global.ingress.className --  Override the `Ingress` class. In most cases this should be left as default
    # @section -- global
    className: "traefik"

    # global.ingress.paths -- Path prefixes that you want to make available externally with the `Ingress`
    # @section -- global
    paths:
      - "/"

  serviceAccount:
    # global.serviceAccount.enabled -- Set to `false` to prevent the `ServiceAccount` from being created
    # @section -- global
    enabled: true

    # global.serviceAccount.name -- `ServiceAccount` name. Use with `global.serviceAccount.enabled: false`
    # to use an existing `ServiceAccount`
    # @default -- `.Release.Name`
    # @section -- global
    name: ""

    # global.serviceAccount.automountServiceAccountToken -- Set to `true` to mount tokens for access to the Kubernetes API. This should almost always be `false`
    # @section -- global
    automountServiceAccountToken: false

    # global.serviceAccount.annotations --Set annotations on the `ServiceAccount`
    # @section -- global
    annotations: {}

image:
  # image.name -- The container image of your application
  # @section -- application
  name: "public.ecr.aws/nginx/nginx"

  # image.tag -- The tag for the image that you want to deploy
  # @section -- application
  tag: "alpine"

# args -- Arguments to be passed to your application container
# @section -- application
args: []

# env -- **Non-secret** environment variables to configure your application. Formatted as `ENV_VAR_NAME: env-var-value`
# @section -- application
env: {}

# envFrom -- Create environment variables from `Secret` or `ConfigMap` resources.
# See https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
# @section -- application
envFrom: []

# secretEnv -- Secret values that are mounted as environment variables. Formatted as `ENV_VAR_NAME: env-var-value`
# in a SOPS encrypted `secrets.yaml` file
# @section -- application
secretEnv: {}

# secretVolume -- Secret values that will be available as files in `/secrets` inside the container.
# Formatted as `file.name: <base64 encoded file>`
# @section -- application
secretVolume: {}

deployment:
  # deployment.replicas -- The minimum number of replicas of the application
  # @section -- application
  replicas: 1

  # deployment.maxReplicas -- (int) The maximum number of replicas of the application
  # @default -- `.Values.deployment.replicas
  # @section -- application
  maxReplicas: null

ports:
  app-port:
    # ports.app-port.port -- The port the application is listening on
    # @section -- application
    port: 8080

    # ports.app-port.protocol -- The protocol the application uses. This should alost always be TCP
    # @section -- application
    protocol: TCP

    # ports.app-port.expose -- Whether the port should be accessible to the cluster and outside world
    # @section -- application
    expose: true

metricsEndpoint:
  # metricsEndpoint.path -- The path to a Prometheus compatible metrics endpoint
  # @section -- application
  path: /metrics

  # metricsEndpoint.port -- The name of the port that the metrics endpoint is listening on
  # @section -- application
  port: app-port

healthcheckEndpoint:
  # healthcheckEndpoint.path -- The path of the applications HTTP healthcheck endpoint
  # @section -- application
  path:
    /health

    # healthcheckEndpoint.port -- TThe name of the port that the healthcheck endpoint is listening on
    # @section -- application
  port: app-port

resources:
  # resources.cpu -- Requested CPU time for the pod
  # @section -- application
  cpu: "100m"

  # resources.memory -- Maximum memory usage for the pod
  # @section -- application
  memory: "64Mi"

pod:
  # pod.additionalVolumes -- Configuration for additional volumes. See example in values.yaml
  additionalVolumes: []
  # - name: dsdsocket
  #   hostPath:
  #     path: /var/run/statsd-exporter

  # pod.additionalVolumeMounts -- Configuration for additional volume mounts. References additionalVolumes, see example in values.yaml
  additionalVolumeMounts: []
  # - name: dsdsocket
  #   mountPath: /socket

  # pod.labels -- Additional labels to add to pods
  labels: {}

  # pod.annotations -- Additional annotations to add to pods
  annotations: {}

  # pod.nodeSelector -- Set a nodeSelector(s) on your pods
  nodeSelector: {}

podLogs:
  # podLogs.pipelineStages -- Grafana logging agent [pipeline stage](https://grafana.com/docs/loki/latest/send-data/promtail/pipelines/)
  pipelineStages: []

# initContainers -- Configuration for [init containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/), which are containers that run before the app container is started.
# @section == application
initContainers:
  []
  # - name: init-myservice
  #   image: nginx
  #   command: ['sh', '-c', "echo 'output'"]

service:
  # service.enabled -- Set to true to expose your application within the Kubernetes cluster
  # @section -- network
  enabled: true

  # service.annotations -- Add annotations to the Service resource
  # @section -- network
  annotations: {}

ciliumNetworkPolicy:
  # ciliumNetworkPolicy.enabled -- Set to false to remove the CiliumNetworkPolicy. You should keep it and configure it
  # @section -- network
  # @ignored
  enabled: true

  # ciliumNetworkPolicy.ingress -- Cilium ingress rules. See examples in values.yaml
  # @section -- network
  ingress: []
  # fromEndpoints:
  # - matchLabels:
  #     app.kubernetes.io/name: frontend # Pods with this label will be able to access your application
  #   toPorts:
  #     - ports:
  #       - port: "8080"
  #         protocol: TCP

  # ciliumNetworkPolicy.egress -- Cilium egress rules. See examples in values.yaml
  # @section -- network
  egress: []
  # - toFQDNs:
  #   - matchName: "my-remote-service.com"
  #   toPorts:
  #     - ports:
  #         - port: "443"
  #           protocol: TCP

  #ciliumNetworkPolicy.externalHttpsServices -- A list of external domain names that your app depends on. See examples in values.yaml
  # @section -- network
  externalHttpsServices: []
  #  - discord.com
  #  - api.openai.com
  #  - api.zoom.us

  # ciliumNetworkPolicy.fromApps -- A list of app names and optional namespace to allow ingress from. See examples in values.yaml
  # @section -- network
  fromApps: []
  # - name: hakawai-gateway
  # - name: email-marketing
  #   namespace: web

  # ciliumNetworkPolicy.toApps -- A list of app names and optional namespace to allow egress to. See examples in values.yaml
  # @section -- network
  toApps: []
  # - name: hakawai-hello-service
  # - name: license-checker
  #   namespace: web

  # @ignored
  ingressControllerEndpointMatchLabels:
    k8s:io.kubernetes.pod.namespace: ingress
    app.kubernetes.io/name: traefik

  # @ignored
  observabilityAgentEndpointMatchLabels:
    k8s:io.kubernetes.pod.namespace: observability
    app.kubernetes.io/name: grafana-agent

infra:
  postgres:
    # infra.postgres.enabled -- Set to `true` to deploy a `PostgresInstance` resource
    # @section -- infra
    enabled: false

    # infra.postgres.create -- Set to `false` to skip creation of the `PostgresInstance` if it has been created elsewhere
    # @section -- infra
    create: true

    # infra.postgres.nameOverride -- Override the `PostgresInstance` name or use with `create: false` to map the secrets of an instance created elsewhere
    # @section -- infra
    nameOverride: ""

    # infra.postgres.size -- Options: micro, small, medium, large or xlarge
    # @default -- `micro`
    # @section -- infra
    size: null

    # infra.postgres.version -- Options: 16.2, 15.6 or 14.11
    # @default -- `"16.2"`
    # @section -- infra
    version: null

    # infra.postgres.multiAz -- (bool) Set to `true` to deploy the `PostgresInstance` across multiple availability zones
    # @default -- `false`
    # @section -- infra
    multiAz: null

  s3Bucket:
    # infra.s3Bucket.enabled -- Set to `true` to deploy an `s3Bucket` resource
    # @section -- infra
    enabled: false

    # infra.s3Bucket.create -- Set to `false` to skip creation of the `s3Bucket` if it has been created elsewhere
    # @section -- infra
    create: true

    # infra.s3Bucket.nameOverride -- Override the `s3Bucket` name or use with `create: false` to map the secrets of an instance created elsewhere
    # @section -- infra
    nameOverride: ""

    # infra.s3Bucket.lifecycleRules -- (list) Configure the `s3Bucket` storage [lifecycle rules](https://marketplace.upbound.io/providers/upbound/provider-aws-s3/v1.2.1/resources/s3.aws.upbound.io/BucketLifecycleConfiguration/v1beta1#doc:spec-forProvider-rule)
    # @default -- `[]`
    # @section -- infra
    lifecycleRules:
      - expiration:
          - days: 0
        status: Disabled

  cloudfront:
    # infra.cloudfront.enabled -- Set to `true` to deploy an `CloudFrontSite` resource
    # @section -- infra
    enabled: false

    # infra.cloudfront.hostedZoneId -- The Route53 hosted zone ID to create the certificates and domain names for the `CloudFrontSite` resource
    # @section -- infra
    hostedZoneId: ""

    # infra.cloudfront.domainName -- The presentation domain name for the `CloudFrontSite` resource
    # @section -- infra
    domainName: ""

    # infra.cloudfront.targetOriginDomainName -- The target origin domain name that the `CloudFrontSite` resource fronts
    # @default -- `.Values.global.ingress.host`
    # @section -- infra
    targetOriginDomainName: ""

    geoRestriction:
      # infra.cloudfront.geoRestriction.restrictionType -- Whether to `allow` or `deny` the configured locations access to the `CloudFrontSite`. Set to `none` to remove all restrictions
      # @section -- infra
      restrictionType: allow

      # infra.cloudfront.geoRestriction.locations -- A list of ISO ALPHA-2 country codes to apply restrictions to
      # @section -- infra
      locations:
        - GB

    # infra.cloudfront.originHeaderAuth -- Set to 'true' to enable authentication between CloudFront and the origin
    # @section -- infra
    originHeaderAuth: true

  redis:
    # infra.redis.enabled -- Set to `true` to deploy a `RedisCluster` resource
    # @section -- infra
    enabled: false
    # infra.redis.nodeGroups -- (int) Set the number of node groups for the `RedisCluster`
    # @section -- infra
    nodeGroups: 1
    # infra.redis.replicasPerNodeGroup -- Set the number of replicas per node group for the `RedisCluster`
    # @section -- infra
    replicasPerNodeGroup: 0
    # infra.redis.size -- Options: micro, small, medium, large or xlarge
    # @default -- `micro`
    # @section -- infra
    size: micro
    # infra.redis.version -- Options: 7.1, 7.0
    # @default -- `7.1`
    # @section -- infra
    version: "7.1"
    # infra.redis.multiAz -- (bool) Set to `true` to deploy the `RedisCluster` across multiple availability zones
    # @default -- `false`
    # @section -- infra
    multiAz: false

# extraDeploy -- Extra Kubernetes configuration
extraDeploy: []

# preDeployCommand -- (string[]) Command to run before install and upgrade of your application. See examples in values.yaml
preDeployCommand:
  []
  # - python
  # - manage.py
  # - migrate

# preRollbackCommand -- (string[]) Command to run before a rollback. See examples in values.yaml
preRollbackCommand:
  []
  # - python
  # - manage.py
  # - rollback
