global:
  aws:
    # global.aws.accountId -- The AWS account that this application is being deployed into
    # @default -- Taken from deployment pipeline environment
    # @section -- global
    accountId: ""
  ingress:
    # global.ingress.enabled -- Set to `true` to expose the application with a Kubernetes `Ingress`
    # @section -- global
    enabled: false

    # global.ingress.host -- Ingress host used to configure cloudfront target
    # @section -- global
    host: ""

    # global.ingress.annotations -- Set annotations on the `Ingress`
    # @section -- global
    annotations: {}

    # global.ingress.className --  Override the `Ingress` class. In most cases this should be left as default
    # @section -- global
    className: ""

    # global.ingress.paths -- Path prefixes that you want to make available externally with the `Ingress`
    # @section -- global
    paths:
      - "/"

  serviceAccount:
    # global.serviceAccount.enabled -- Set to `false` to prevent the `ServiceAccount` from being created
    # @section -- global
    enabled: true

    # global.serviceAccount.name -- `ServiceAccount` name. Use with `global.serviceAccount.enabled: false`
    # to use an existing `ServiceAccount`
    # @default -- `.Release.Name`
    # @section -- global
    name: ""

    # global.serviceAccount.automountServiceAccountToken -- Set to `true` to mount tokens for access to the Kubernetes API. This should almost always be `false`
    # @section -- global
    automountServiceAccountToken: false

    # global.serviceAccount.annotations --Set annotations on the `ServiceAccount`
    # @section -- global
    annotations: {}

image:
  # image.name -- The container image of your application
  # @section -- application
  name: "public.ecr.aws/nginx/nginx"

  # image.tag -- The tag for the image that you want to deploy
  # @section -- application
  tag: "alpine"

# args -- Arguments to be passed to your application container
# @section -- application
args: []

# env -- **Non-secret** environment variables to configure your application. Formatted as `ENV_VAR_NAME: env-var-value`
# @section -- application
env: {}

# envFrom -- Create environment variables from `Secret` or `ConfigMap` resources.
# See https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
# @section -- application
envFrom: []

# secretEnv -- Secret values that are mounted as environment variables. Formatted as `ENV_VAR_NAME: env-var-value`
# in a SOPS encrypted `secrets.yaml` file
# @section -- application
secretEnv: {}

# secretVolume -- Secret values that will be available as files in `/secrets` inside the container.
# Formatted as `file.name: <base64 encoded file>`
# @section -- application
secretVolume: {}

deployment:
  # deployment.replicas -- The minimum number of replicas of the application
  replicas: 1

  # deployment.maxReplicas -- (int) The maximum number of replicas of the application
  # @default -- `.Values.deployment.replicas`
  maxReplicas: null

# -- Configuration for the ports that the application listens on.
ports:
  app-port:
    # -- The port the application is running on
    port: 8080
    # -- The protocol the application uses
    protocol: TCP
    # -- Whether the port should be accessible to the cluster and outside world.
    expose: true

metricsEndpoint:
  # -- The path of the metrics endpoint
  path: /metrics
  # -- The port that the metrics endpoint is exposed on. Referenced by the port's name
  port: app-port

# -- Configuration for startup, liveness and readiness probes
healthcheckEndpoint:
  # -- The path of the healthcheck endpoint
  path: /health
  # -- The port that the healthcheck endpoint is exposed on. Referenced by the port's name
  port: app-port

resources:
  # -- Requested CPU time for the pod
  cpu: "100m"
  # -- Maximum memory usage for the pod
  memory: "64Mi"

pod:
  # -- Configuration for additional volumes. See example in values.yaml
  additionalVolumes: []
  # - name: dsdsocket
  #   hostPath:
  #     path: /var/run/statsd-exporter

  # -- Configuration for additional volume mounts. References additionalVolumes, see example in values.yaml
  additionalVolumeMounts: []
  # - name: dsdsocket
  #   mountPath: /socket

podLogs:
  # -- Grafana Loki pipeline stages configuration. See https://grafana.com/docs/loki/latest/send-data/promtail/pipelines/
  pipelineStages: []

# -- Configuration for [init containers](https://kubernetes.io/docs/concepts/workloads/pods/init-containers/), which are containers that run before the app container is started.
initContainers:
  []
  # - name: init-myservice
  #   image: nginx
  #   command: ['sh', '-c', "echo 'output'"]

service:
  # -- Adds a service to expose the application to the rest of the cluster
  enabled: true
  annotations: {}

# -- Configuration for the ciliumNetworkPolicy, allowing restriction of network access to pods.
ciliumNetworkPolicy:
  enabled: true

  # -- Cilium ingress rules. See examples below.
  ingress: []
  # fromEndpoints:
  # - matchLabels:
  #     app.kubernetes.io/name: frontend # Pods with this label will be able to access your application
  #   toPorts:
  #     - ports:
  #       - port: "8080"
  #         protocol: TCP

  # -- Cilium egress rules. See examples below.
  egress: []
  # - toFQDNs:
  #   - matchName: "my-remote-service.com"

  # -- Label matchers for the ingress controller. Used so that the ingress controller can access your application.
  ingressControllerEndpointMatchLabels:
    k8s:io.kubernetes.pod.namespace: ingress
    app.kubernetes.io/name: traefik

  observabilityAgentEndpointMatchLabels:
    k8s:io.kubernetes.pod.namespace: observability
    app.kubernetes.io/name: grafana-agent

infra:
  postgres:
    # infra.postgres.enabled -- Set to `true` to deploy a `PostgresInstance` resource
    # @section -- infra
    enabled: false

    # infra.postgres.create -- Set to `false` to skip creation of the `PostgresInstance` if it has been created elsewhere
    # @section -- infra
    create: true

    # infra.postgres.nameOverride -- Override the `PostgresInstance` name or use with `create: false` to map the secrets of an instance created elsewhere
    # @section -- infra
    nameOverride: ""

    # infra.postgres.size -- Options: micro, small, medium, large or xlarge
    # @default -- `micro`
    # @section -- infra
    size: null

    # infra.postgres.version -- Options: 16.2, 15.6 or 14.11
    # @default -- `"16.2"`
    # @section -- infra
    version: null

    # infra.postgres.multiAz -- (bool) Set to `true` to deploy the `PostgresInstance` across multiple availability zones
    # @default -- `false`
    # @section -- infra
    multiAz: null

  s3Bucket:
    # infra.s3Bucket.enabled -- Set to `true` to deploy an `s3Bucket` resource
    # @section -- infra
    enabled: false

    # infra.s3Bucket.create -- Set to `false` to skip creation of the `s3Bucket` if it has been created elsewhere
    # @section -- infra
    create: true

    # infra.s3Bucket.nameOverride -- Override the `s3Bucket` name or use with `create: false` to map the secrets of an instance created elsewhere
    # @section -- infra
    nameOverride: ""

    # infra.s3Bucket.lifecycleRules -- (list) Configure the `s3Bucket` storage [lifecycle rules](https://marketplace.upbound.io/providers/upbound/provider-aws-s3/v1.2.1/resources/s3.aws.upbound.io/BucketLifecycleConfiguration/v1beta1#doc:spec-forProvider-rule)
    # @default -- `[]`
    # @section -- infra
    lifecycleRules:
      - expiration:
          - days: 0
        status: Disabled

  cloudfront:
    # infra.cloudfront.enabled -- Set to `true` to deploy an `CloudFrontSite` resource
    # @section -- infra
    enabled: false

    # infra.cloudfront.hostedZoneId -- The Route53 hosted zone ID to create the certificates and domain names for the `CloudFrontSite` resource
    # @section -- infra
    hostedZoneId: ""

    # infra.cloudfront.domainName -- The presentation domain name for the `CloudFrontSite` resource
    # @section -- infra
    domainName: ""

    # infra.cloudfront.targetOriginDomainName -- The target origin domain name that the `CloudFrontSite` resource fronts
    # @default -- `.Values.global.ingress.host`
    # @section -- infra
    targetOriginDomainName: ""

    geoRestriction:
      # infra.cloudfront.geoRestriction.restrictionType -- Whether to `allow` or `deny` the configured locations access to the `CloudFrontSite`. Set to `none` to remove all restrictions
      # @section -- infra
      restrictionType: allow

      # infra.cloudfront.geoRestriction.locations -- A list of ISO ALPHA-2 country codes to apply restrictions to
      # @section -- infra
      locations:
        - GB

# -- Extra Kubernetes configuration
extraDeploy: []

# -- (string[]) Command to run before install and upgrade of your application.
preDeployCommand:
  []
  # - python
  # - manage.py
  # - migrate

# -- (string[]) Command to run before a rollback.
preRollbackCommand:
  []
  # - python
  # - manage.py
  # - rollback
